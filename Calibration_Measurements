#include <Wire.h>

// ---------- ADXL375 I2C addresses ----------
#define ADXL_ADDR_53 0x53   // ALT=GND
#define ADXL_ADDR_1D 0x1D   // ALT=VDDIO

// ---------- ADXL375 registers ----------
#define REG_DEVID         0x00
#define REG_BW_RATE       0x2C   // 0x0C = 400 Hz ODR (~200 Hz BW)
#define REG_POWER_CTL     0x2D
#define REG_DATA_FORMAT   0x31
#define REG_DATAX0        0x32   // .. 0x37 (X, Y, Z data)

// ---------- constants ----------
#define BW_RATE_400HZ     0x0C   // ODR=400 Hz (~200 Hz BW)
#define MEASURE           0x08

// ---------- user configuration ----------
const float G_PER_LSB = 0.049f;          // typ. ~49 mg/LSB for ADXL375
const uint32_t PRINT_INTERVAL_MS = 50;   // Print every 50ms (20 Hz)

// ---------- globals ----------
uint8_t ADXL_ADDR = ADXL_ADDR_53;
uint32_t last_print_time = 0;

// ---------- helpers ----------
static inline bool writeReg(uint8_t reg, uint8_t val) {
  Wire.beginTransmission(ADXL_ADDR);
  Wire.write(reg);
  Wire.write(val);
  return Wire.endTransmission(true) == 0;
}

static inline bool readXYZ_g(float &gx, float &gy, float &gz) {
  uint8_t raw[6];
  Wire.beginTransmission(ADXL_ADDR);
  Wire.write(REG_DATAX0);
  if (Wire.endTransmission(false) != 0) return false;
  if (Wire.requestFrom(ADXL_ADDR, (uint8_t)6) != 6) return false;
  
  raw[0]=Wire.read(); raw[1]=Wire.read();  // X LSB, X MSB
  raw[2]=Wire.read(); raw[3]=Wire.read();  // Y LSB, Y MSB
  raw[4]=Wire.read(); raw[5]=Wire.read();  // Z LSB, Z MSB
  
  int16_t rx = (int16_t)((uint16_t)raw[1]<<8 | raw[0]);
  int16_t ry = (int16_t)((uint16_t)raw[3]<<8 | raw[2]);
  int16_t rz = (int16_t)((uint16_t)raw[5]<<8 | raw[4]);
  
  gx = rx * G_PER_LSB; 
  gy = ry * G_PER_LSB; 
  gz = rz * G_PER_LSB;
  return true;
}

// ---------- sensor init ----------
bool adxl375_begin() {
  // Probe address
  Wire.beginTransmission(ADXL_ADDR);
  if (Wire.endTransmission(true) != 0) ADXL_ADDR = ADXL_ADDR_1D;

  // Verify DEVID
  uint8_t id=0;
  Wire.beginTransmission(ADXL_ADDR); 
  Wire.write(REG_DEVID);
  if (Wire.endTransmission(false) != 0 || Wire.requestFrom(ADXL_ADDR, (uint8_t)1) != 1) return false;
  id = Wire.read();
  if (id != 0xE5) return false;

  // Configure sensor: 400 Hz ODR, ±200g range, start measuring
  if (!writeReg(REG_BW_RATE,     BW_RATE_400HZ)) return false; // 400 Hz ODR
  if (!writeReg(REG_DATA_FORMAT, 0x00))          return false; // ±200 g range
  if (!writeReg(REG_POWER_CTL,   MEASURE))       return false; // Start measuring

  Serial.print(F("ADXL375 initialized at I2C address 0x"));
  Serial.println(ADXL_ADDR, HEX);
  return true;
}

void setup() {
  Serial.begin(115200); 
  while (!Serial) {}
  Serial.println(F("ADXL375 Continuous Acceleration Monitor"));
  Serial.println(F("Printing X, Y, Z acceleration values in g's"));
  Serial.println();

  Wire.begin();
  Wire.setClock(400000);   // I2C 400 kHz

  if (!adxl375_begin()) {
    Serial.println(F("ADXL375 initialization failed!"));
    Serial.println(F("Check wiring and I2C connections."));
    while (1) delay(1000);
  }

  Serial.println(F("Time(ms)\tX(g)\t\tY(g)\t\tZ(g)\t\tMagnitude(g)"));
  Serial.println(F("-------\t\t----\t\t----\t\t----\t\t-----------"));
  
  last_print_time = millis();
}

void loop() {
  uint32_t current_time = millis();
  
  // Print at specified interval
  if (current_time - last_print_time >= PRINT_INTERVAL_MS) {
    float xg, yg, zg;
    
    if (readXYZ_g(xg, yg, zg)) {
      // Calculate magnitude (total acceleration)
      float magnitude = sqrt(xg*xg + yg*yg + zg*zg);
      
      // Print timestamp and all axis values
      Serial.print(current_time);
      Serial.print(F("\t\t"));
      
      Serial.print(xg, 3);
      Serial.print(F("\t\t"));
      
      Serial.print(yg, 3);
      Serial.print(F("\t\t"));
      
      Serial.print(zg, 3);
      Serial.print(F("\t\t"));
      
      Serial.print(magnitude, 3);
      Serial.println();
      
    } else {
      Serial.println(F("Error reading sensor data"));
    }
    
    last_print_time = current_time;
  }
}
